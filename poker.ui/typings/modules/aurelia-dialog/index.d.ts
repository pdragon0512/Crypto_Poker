// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dialog/master/dist/commonjs/dialog-configuration.d.ts
declare module '~aurelia-dialog/dist/commonjs/dialog-configuration' {
import { FrameworkConfiguration } from 'aurelia-framework';
import { RendererStatic } from '~aurelia-dialog/dist/commonjs/renderer';
import { DialogSettings } from '~aurelia-dialog/dist/commonjs/dialog-settings';
export type DialogResourceName = 'ux-dialog' | 'ux-dialog-header' | 'ux-dialog-body' | 'ux-dialog-footer' | 'attach-focus';
/**
 * A configuration builder for the dialog plugin.
 */
export class DialogConfiguration {
    private fwConfig;
    private renderer;
    private cssText;
    private resources;
    /**
     * The configuration settings.
     */
    settings: DialogSettings;
    constructor(frameworkConfiguration: FrameworkConfiguration, applySetter: (apply: () => void) => void);
    private _apply();
    /**
     * Selects the Aurelia conventional defaults for the dialog plugin.
     * @return This instance.
     */
    useDefaults(): this;
    /**
     * Exports the standard set of dialog behaviors to Aurelia's global resources.
     * @return This instance.
     */
    useStandardResources(): this;
    /**
     * Exports the chosen dialog element or view to Aurelia's global resources.
     * @param resourceName The name of the dialog resource to export.
     * @return This instance.
     */
    useResource(resourceName: DialogResourceName): this;
    /**
     * Configures the plugin to use a specific dialog renderer.
     * @param renderer A type that implements the Renderer interface.
     * @param settings Global settings for the renderer.
     * @return This instance.
     */
    useRenderer(renderer: RendererStatic, settings?: DialogSettings): this;
    /**
     * Configures the plugin to use specific css.
     * @param cssText The css to use in place of the default styles.
     * @return This instance.
     */
    useCSS(cssText: string): this;
}
}
declare module 'aurelia-dialog/dist/commonjs/dialog-configuration' {
export * from '~aurelia-dialog/dist/commonjs/dialog-configuration';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dialog/master/dist/commonjs/ux-dialog.d.ts
declare module '~aurelia-dialog/dist/commonjs/ux-dialog' {
export class UxDialog {
}
}
declare module 'aurelia-dialog/dist/commonjs/ux-dialog' {
export * from '~aurelia-dialog/dist/commonjs/ux-dialog';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dialog/master/dist/commonjs/ux-dialog-header.d.ts
declare module '~aurelia-dialog/dist/commonjs/ux-dialog-header' {
import { ComponentBind } from '~aurelia-dialog~aurelia-templating/dist/aurelia-templating';
import { DialogController } from '~aurelia-dialog/dist/commonjs/dialog-controller';
export class UxDialogHeader implements ComponentBind {
    controller: DialogController;
    showCloseButton: boolean | undefined;
    constructor(controller: DialogController);
    bind(): void;
}
}
declare module 'aurelia-dialog/dist/commonjs/ux-dialog-header' {
export * from '~aurelia-dialog/dist/commonjs/ux-dialog-header';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dialog/master/dist/commonjs/ux-dialog-body.d.ts
declare module '~aurelia-dialog/dist/commonjs/ux-dialog-body' {
export class UxDialogBody {
}
}
declare module 'aurelia-dialog/dist/commonjs/ux-dialog-body' {
export * from '~aurelia-dialog/dist/commonjs/ux-dialog-body';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dialog/master/dist/commonjs/ux-dialog-footer.d.ts
declare module '~aurelia-dialog/dist/commonjs/ux-dialog-footer' {
import { DialogController } from '~aurelia-dialog/dist/commonjs/dialog-controller';
/**
 * View-model for footer of Dialog.
 */
export class UxDialogFooter {
    controller: DialogController;
    static isCancelButton(value: string): boolean;
    buttons: any[];
    useDefaultButtons: boolean;
    constructor(controller: DialogController);
    close(buttonValue: string): void;
    useDefaultButtonsChanged(newValue: boolean): void;
}
}
declare module 'aurelia-dialog/dist/commonjs/ux-dialog-footer' {
export * from '~aurelia-dialog/dist/commonjs/ux-dialog-footer';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/templating/master/dist/aurelia-templating.d.ts
declare module '~aurelia-dialog~aurelia-templating/dist/aurelia-templating' {
import * as LogManager from 'aurelia-logging';
import {
  metadata,
  Origin,
  protocol
} from 'aurelia-metadata';
import {
  DOM,
  PLATFORM,
  FEATURE
} from 'aurelia-pal';
import {
  relativeToFile
} from 'aurelia-path';
import {
  TemplateRegistryEntry,
  Loader
} from 'aurelia-loader';
import {
  inject,
  Container,
  resolver
} from 'aurelia-dependency-injection';
import {
  Binding,
  createOverrideContext,
  ValueConverterResource,
  BindingBehaviorResource,
  subscriberCollection,
  bindingMode,
  ObserverLocator,
  EventManager
} from 'aurelia-binding';
import {
  TaskQueue
} from 'aurelia-task-queue';
export interface EventHandler {
  eventName: string;
  bubbles: boolean;
  dispose: Function;
  handler: Function;
}

/**
* Specifies how a view should be created.
*/
export interface ViewCreateInstruction {
  
  /**
    * Indicates that the view is being created by enhancing existing DOM.
    */
  enhance?: boolean;
  
  /**
    * Specifies a key/value lookup of part replacements for the view being created.
    */
  partReplacements?: Object;
}

/**
* Implemented by classes that describe how a view factory should be loaded.
*/
export interface ViewStrategy {
  
  /**
    * Loads a view factory.
    * @param viewEngine The view engine to use during the load process.
    * @param compileInstruction Additional instructions to use during compilation of the view.
    * @param loadContext The loading context used for loading all resources and dependencies.
    * @param target A class from which to extract metadata of additional resources to load.
    * @return A promise for the view factory that is produced by this strategy.
    */
  loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext, target?: any): Promise<ViewFactory>;
}

/**
* View engine hooks that enable a view resource to provide custom processing during the compilation or creation of a view.
*/
export interface ViewEngineHooks {
  
  /**
    * Invoked before a template is compiled.
    * @param content The DocumentFragment to compile.
    * @param resources The resources to compile the view against.
    * @param instruction The compilation instruction associated with the compilation process.
    */
  beforeCompile?: (content: DocumentFragment, resources: ViewResources, instruction: ViewCompileInstruction) => void;
  
  /**
    * Invoked after a template is compiled.
    * @param viewFactory The view factory that was produced from the compilation process.
    */
  afterCompile?: (viewFactory: ViewFactory) => void;
  
  /**
    * Invoked before a view is created.
    * @param viewFactory The view factory that will be used to create the view.
    * @param container The DI container used during view creation.
    * @param content The cloned document fragment representing the view.
    * @param instruction The view creation instruction associated with this creation process.
    */
  beforeCreate?: (viewFactory: ViewFactory, container: Container, content: DocumentFragment, instruction: ViewCreateInstruction) => void;
  
  /**
    * Invoked after a view is created.
    * @param view The view that was created by the factory.
    */
  afterCreate?: (view: View) => void;
  
  /**
    * Invoked after the bindingContext and overrideContext are configured on the view but before the view is bound.
    * @param view The view that was created by the factory.
    */
  beforeBind?: (view: View) => void;
  
  /**
    * Invoked before the view is unbind. The bindingContext and overrideContext are still available on the view.
    * @param view The view that was created by the factory.
    */
  beforeUnbind?: (view: View) => void;
}

/* eslint no-unused-vars: 0, no-constant-condition: 0 */
/**
* Represents a node in the view hierarchy.
*/
export interface ViewNode {
  
  /**
    * Binds the node and it's children.
    * @param bindingContext The binding context to bind to.
    * @param overrideContext A secondary binding context that can override the standard context.
    */
  bind(bindingContext: Object, overrideContext?: Object): void;
  
  /**
    * Triggers the attach for the node and its children.
    */
  attached(): void;
  
  /**
    * Triggers the detach for the node and its children.
    */
  detached(): void;
  
  /**
    * Unbinds the node and its children.
    */
  unbind(): void;
}

/**
* An optional interface describing the created convention.
*/
export interface ComponentCreated {
  
  /**
      * Implement this hook if you want to perform custom logic after the constructor has been called.
      * At this point in time, the view has also been created and both the view-model and the view
      * are connected to their controller. The hook will recieve the instance of the "owningView".
      * This is the view that the component is declared inside of. If the component itself has a view,
      * this will be passed second.
      */
  created(owningView: View, myView: View): void;
}

/**
* An optional interface describing the bind convention.
*/
/**
* An optional interface describing the bind convention.
*/
export interface ComponentBind {
  
  /**
      * Implement this hook if you want to perform custom logic when databinding is activated on the view and view-model.
      * The "binding context" to which the component is being bound will be passed first.
      * An "override context" will be passed second. The override context contains information used to traverse
      * the parent hierarchy and can also be used to add any contextual properties that the component wants to add.
      */
  bind(bindingContext: any, overrideContext: any): void;
}

/**
* An optional interface describing the attached convention.
*/
/**
* An optional interface describing the attached convention.
*/
export interface ComponentAttached {
  
  /**
      * Implement this hook if you want to perform custom logic when the component is attached to the DOM (in document).
      */
  attached(): void;
}

/**
* An optional interface describing the detached convention.
*/
/**
* An optional interface describing the detached convention.
*/
export interface ComponentDetached {
  
  /**
      * Implement this hook if you want to perform custom logic if/when the component is removed from the the DOM.
      */
  detached(): void;
}

/**
* An optional interface describing the unbind convention.
*/
/**
* An optional interface describing the unbind convention.
*/
export interface ComponentUnbind {
  
  /**
      * Implement this hook if you want to perform custom logic after the component is detached and unbound.
      */
  unbind(): void;
}

/**
* An optional interface describing the getViewStrategy convention for dynamic components (used with the compose element or the router).
*/
/**
* An optional interface describing the getViewStrategy convention for dynamic components (used with the compose element or the router).
*/
export interface DynamicComponentGetViewStrategy {
  
  /**
      * Implement this hook if you want to provide custom view strategy when this component is used with the compose element or the router.
      */
  getViewStrategy(): string | ViewStrategy;
}

/**
* Instructs the composition engine how to dynamically compose a component.
*/
export interface CompositionContext {
  
  /**
    * The parent Container for the component creation.
    */
  container: Container;
  
  /**
    * The child Container for the component creation. One will be created from the parent if not provided.
    */
  childContainer?: Container;
  
  /**
    * The context in which the view model is executed in.
    */
  bindingContext: any;
  
  /**
    * A secondary binding context that can override the standard context.
    */
  overrideContext?: any;
  
  /**
    * The view model url or instance for the component.
    */
  viewModel?: any;
  
  /**
    * Data to be passed to the "activate" hook on the view model.
    */
  model?: any;
  
  /**
    * The HtmlBehaviorResource for the component.
    */
  viewModelResource?: HtmlBehaviorResource;
  
  /**
    * The view resources for the view in which the component should be created.
    */
  viewResources: ViewResources;
  
  /**
    * The view inside which this composition is happening.
    */
  owningView?: View;
  
  /**
    * The view url or view strategy to override the default view location convention.
    */
  view?: string | ViewStrategy;
  
  /**
    * The slot to push the dynamically composed component into.
    */
  viewSlot: ViewSlot;
  
  /**
    * Should the composition system skip calling the "activate" hook on the view model.
    */
  skipActivation?: boolean;
  
  /**
    * The element that will parent the dynamic component.
    * It will be registered in the child container of this composition.
    */
  host?: Element;
}

/**
* Instructs the framework in how to enhance an existing DOM structure.
*/
export interface EnhanceInstruction {
  
  /**
    * The DI container to use as the root for UI enhancement.
    */
  container?: Container;
  
  /**
    * The element to enhance.
    */
  element: Element;
  
  /**
    * The resources available for enhancement.
    */
  resources?: ViewResources;
  
  /**
    * A binding context for the enhancement.
    */
  bindingContext?: Object;
  
  /**
    * A secondary binding context that can override the standard context.
    */
  overrideContext?: any;
}

/**
* List the events that an Animator should raise.
*/
export const animationEvent: any;

/**
 * An abstract class representing a mechanism for animating the DOM during various DOM state transitions.
 */
export class Animator {
  
  /**
     * Execute an 'enter' animation on an element
     * @param element Element to animate
     * @returns Resolved when the animation is done
     */
  enter(element: HTMLElement): Promise<boolean>;
  
  /**
     * Execute a 'leave' animation on an element
     * @param element Element to animate
     * @returns Resolved when the animation is done
     */
  leave(element: HTMLElement): Promise<boolean>;
  
  /**
     * Add a class to an element to trigger an animation.
     * @param element Element to animate
     * @param className Properties to animate or name of the effect to use
     * @returns Resolved when the animation is done
     */
  removeClass(element: HTMLElement, className: string): Promise<boolean>;
  
  /**
     * Add a class to an element to trigger an animation.
     * @param element Element to animate
     * @param className Properties to animate or name of the effect to use
     * @returns Resolved when the animation is done
     */
  addClass(element: HTMLElement, className: string): Promise<boolean>;
  
  /**
     * Execute a single animation.
     * @param element Element to animate
     * @param className Properties to animate or name of the effect to use. For css animators this represents the className to be added and removed right after the animation is done.
     * @param options options for the animation (duration, easing, ...)
     * @returns Resolved when the animation is done
     */
  animate(element: HTMLElement | Array<HTMLElement>, className: string): Promise<boolean>;
  
  /**
     * Run a sequence of animations one after the other.
     * for example: animator.runSequence("fadeIn","callout")
     * @param sequence An array of effectNames or classNames
     * @returns Resolved when all animations are done
     */
  runSequence(animations: Array<any>): Promise<boolean>;
  
  /**
     * Register an effect (for JS based animators)
     * @param effectName identifier of the effect
     * @param properties Object with properties for the effect
     */
  registerEffect(effectName: string, properties: Object): void;
  
  /**
     * Unregister an effect (for JS based animators)
     * @param effectName identifier of the effect
     */
  unregisterEffect(effectName: string): void;
}

/**
* A mechanism by which an enlisted async render operation can notify the owning transaction when its work is done.
*/
export class CompositionTransactionNotifier {
  constructor(owner?: any);
  
  /**
    * Notifies the owning transaction that its work is done.
    */
  done(): void;
}

/**
* Referenced by the subsytem which wishes to control a composition transaction.
*/
export class CompositionTransactionOwnershipToken {
  constructor(owner?: any);
  
  /**
    * Allows the transaction owner to wait for the completion of all child compositions.
    * @return A promise that resolves when all child compositions are done.
    */
  waitForCompositionComplete(): Promise<void>;
  
  /**
    * Used internall to resolve the composition complete promise.
    */
  resolve(): void;
}

/**
* Enables an initiator of a view composition to track any internal async rendering processes for completion.
*/
export class CompositionTransaction {
  
  /**
    * Creates an instance of CompositionTransaction.
    */
  constructor();
  
  /**
    * Attempt to take ownership of the composition transaction.
    * @return An ownership token if successful, otherwise null.
    */
  tryCapture(): CompositionTransactionOwnershipToken;
  
  /**
    * Enlist an async render operation into the transaction.
    * @return A completion notifier.
    */
  enlist(): CompositionTransactionNotifier;
}
export class ViewEngineHooksResource {
  constructor();
  initialize(container?: any, target?: any): any;
  register(registry?: any, name?: any): any;
  load(container?: any, target?: any): any;
  static convention(name?: any): any;
}
export function viewEngineHooks(target?: any): any;

/**
 * Dispatches subscribets to and publishes events in the DOM.
 * @param element
 */
/**
 * Dispatches subscribets to and publishes events in the DOM.
 * @param element
 */
export class ElementEvents {
  constructor(element: Element);
  
  /**
     * Dispatches an Event on the context element.
     * @param eventName
     * @param detail
     * @param bubbles
     * @param cancelable
     */
  publish(eventName: string, detail?: Object, bubbles?: boolean, cancelable?: boolean): any;
  
  /**
     * Adds and Event Listener on the context element.
     * @param eventName
     * @param handler
     * @param bubbles
     * @return Returns the eventHandler containing a dispose method
     */
  subscribe(eventName: string, handler: Function, bubbles?: boolean): EventHandler;
  
  /**
     * Adds an Event Listener on the context element, that will be disposed on the first trigger.
     * @param eventName
     * @param handler
     * @param bubbles
     * @return Returns the eventHandler containing a dispose method
     */
  subscribeOnce(eventName: String, handler: Function, bubbles?: Boolean): EventHandler;
  
  /**
     * Removes all events that are listening to the specified eventName.
     * @param eventName
     */
  dispose(eventName: string): void;
  
  /**
     * Removes all event handlers.
     */
  disposeAll(): any;
}

/**
* A context that flows through the view resource load process.
*/
export class ResourceLoadContext {
  dependencies: Object;
  
  /**
    * Creates an instance of ResourceLoadContext.
    */
  constructor();
  
  /**
    * Tracks a dependency that is being loaded.
    * @param url The url of the dependency.
    */
  addDependency(url: string): void;
  
  /**
    * Checks if the current context includes a load of the specified url.
    * @return True if the url is being loaded in the context; false otherwise.
    */
  hasDependency(url: string): boolean;
}

/**
* Specifies how a view should be compiled.
*/
export class ViewCompileInstruction {
  targetShadowDOM: boolean;
  compileSurrogate: boolean;
  associatedModuleId: any;
  
  /**
    * The normal configuration for view compilation.
    */
  static normal: ViewCompileInstruction;
  
  /**
    * Creates an instance of ViewCompileInstruction.
    * @param targetShadowDOM Should the compilation target the Shadow DOM.
    * @param compileSurrogate Should the compilation also include surrogate bindings and behaviors.
    */
  constructor(targetShadowDOM?: boolean, compileSurrogate?: boolean);
}

/**
* Indicates how a custom attribute or element should be instantiated in a view.
*/
/**
* Indicates how a custom attribute or element should be instantiated in a view.
*/
export class BehaviorInstruction {
  initiatedByBehavior: boolean;
  enhance: boolean;
  partReplacements: any;
  viewFactory: ViewFactory;
  originalAttrName: string;
  skipContentProcessing: boolean;
  contentFactory: any;
  viewModel: Object;
  anchorIsContainer: boolean;
  host: Element;
  attributes: Object;
  type: HtmlBehaviorResource;
  attrName: string;
  inheritBindingContext: boolean;
  
  /**
    * A default behavior used in scenarios where explicit configuration isn't available.
    */
  static normal: BehaviorInstruction;
  
  /**
    * Creates an instruction for element enhancement.
    * @return The created instruction.
    */
  static enhance(): BehaviorInstruction;
  
  /**
    * Creates an instruction for unit testing.
    * @param type The HtmlBehaviorResource to create.
    * @param attributes A key/value lookup of attributes for the behaior.
    * @return The created instruction.
    */
  static unitTest(type: HtmlBehaviorResource, attributes: Object): BehaviorInstruction;
  
  /**
    * Creates a custom element instruction.
    * @param node The node that represents the custom element.
    * @param type The HtmlBehaviorResource to create.
    * @return The created instruction.
    */
  static element(node: Node, type: HtmlBehaviorResource): BehaviorInstruction;
  
  /**
    * Creates a custom attribute instruction.
    * @param attrName The name of the attribute.
    * @param type The HtmlBehaviorResource to create.
    * @return The created instruction.
    */
  static attribute(attrName: string, type?: HtmlBehaviorResource): BehaviorInstruction;
  
  /**
    * Creates a dynamic component instruction.
    * @param host The element that will parent the dynamic component.
    * @param viewModel The dynamic component's view model instance.
    * @param viewFactory A view factory used in generating the component's view.
    * @return The created instruction.
    */
  static dynamic(host: Element, viewModel: Object, viewFactory: ViewFactory): BehaviorInstruction;
  
  /**
    * Creates an instance of BehaviorInstruction.
    */
  constructor();
}

/**
* Provides all the instructions for how a target element should be enhanced inside of a view.
*/
export class TargetInstruction {
  injectorId: number;
  parentInjectorId: number;
  shadowSlot: boolean;
  slotName: string;
  slotFallbackFactory: any;
  contentExpression: any;
  expressions: Array<Object>;
  behaviorInstructions: Array<BehaviorInstruction>;
  providers: Array<Function>;
  viewFactory: ViewFactory;
  anchorIsContainer: boolean;
  elementInstruction: BehaviorInstruction;
  lifting: boolean;
  values: Object;
  
  /**
    * An empty array used to represent a target with no binding expressions.
    */
  static noExpressions: any;
  
  /**
    * Creates an instruction that represents a shadow dom slot.
    * @param parentInjectorId The id of the parent dependency injection container.
    * @return The created instruction.
    */
  static shadowSlot(parentInjectorId: number): TargetInstruction;
  
  /**
    * Creates an instruction that represents a binding expression in the content of an element.
    * @param expression The binding expression.
    * @return The created instruction.
    */
  static contentExpression(expression?: any): TargetInstruction;
  
  /**
    * Creates an instruction that represents content that was lifted out of the DOM and into a ViewFactory.
    * @param parentInjectorId The id of the parent dependency injection container.
    * @param liftingInstruction The behavior instruction of the lifting behavior.
    * @return The created instruction.
    */
  static lifting(parentInjectorId: number, liftingInstruction: BehaviorInstruction): TargetInstruction;
  
  /**
    * Creates an instruction that represents an element with behaviors and bindings.
    * @param injectorId The id of the dependency injection container.
    * @param parentInjectorId The id of the parent dependency injection container.
    * @param providers The types which will provide behavior for this element.
    * @param behaviorInstructions The instructions for creating behaviors on this element.
    * @param expressions Bindings, listeners, triggers, etc.
    * @param elementInstruction The element behavior for this element.
    * @return The created instruction.
    */
  static normal(injectorId: number, parentInjectorId: number, providers: Array<Function>, behaviorInstructions: Array<BehaviorInstruction>, expressions: Array<Object>, elementInstruction: BehaviorInstruction): TargetInstruction;
  
  /**
    * Creates an instruction that represents the surrogate behaviors and bindings for an element.
    * @param providers The types which will provide behavior for this element.
    * @param behaviorInstructions The instructions for creating behaviors on this element.
    * @param expressions Bindings, listeners, triggers, etc.
    * @param values A key/value lookup of attributes to transplant.
    * @return The created instruction.
    */
  static surrogate(providers: Array<Function>, behaviorInstructions: Array<BehaviorInstruction>, expressions: Array<Object>, values: Object): TargetInstruction;
  
  /**
    * Creates an instance of TargetInstruction.
    */
  constructor();
}

/**
* Decorator: Indicates that the decorated class/object is a view strategy.
*/
/**
* Decorator: Indicates that the decorated class/object is a view strategy.
*/
export const viewStrategy: Function;

/**
* A view strategy that loads a view relative to its associated view-model.
*/
export class RelativeViewStrategy {
  
  /**
    * Creates an instance of RelativeViewStrategy.
    * @param path The relative path to the view.
    */
  constructor(path: string);
  
  /**
    * Loads a view factory.
    * @param viewEngine The view engine to use during the load process.
    * @param compileInstruction Additional instructions to use during compilation of the view.
    * @param loadContext The loading context used for loading all resources and dependencies.
    * @param target A class from which to extract metadata of additional resources to load.
    * @return A promise for the view factory that is produced by this strategy.
    */
  loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext, target?: any): Promise<ViewFactory>;
  
  /**
    * Makes the view loaded by this strategy relative to the provided file path.
    * @param file The path to load the view relative to.
    */
  makeRelativeTo(file: string): void;
}

/**
* A view strategy based on naming conventions.
*/
export class ConventionalViewStrategy {
  
  /**
    * Creates an instance of ConventionalViewStrategy.
    * @param viewLocator The view locator service for conventionally locating the view.
    * @param origin The origin of the view model to conventionally load the view for.
    */
  constructor(viewLocator: ViewLocator, origin: Origin);
  
  /**
    * Loads a view factory.
    * @param viewEngine The view engine to use during the load process.
    * @param compileInstruction Additional instructions to use during compilation of the view.
    * @param loadContext The loading context used for loading all resources and dependencies.
    * @param target A class from which to extract metadata of additional resources to load.
    * @return A promise for the view factory that is produced by this strategy.
    */
  loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext, target?: any): Promise<ViewFactory>;
}

/**
* A view strategy that indicates that the component has no view that the templating engine needs to manage.
* Typically used when the component author wishes to take over fine-grained rendering control.
*/
export class NoViewStrategy {
  
  /**
    * Creates an instance of NoViewStrategy.
    * @param dependencies A list of view resource dependencies of this view.
    * @param dependencyBaseUrl The base url for the view dependencies.
    */
  constructor(dependencies?: Array<string | Function | Object>, dependencyBaseUrl?: string);
  
  /**
    * Loads a view factory.
    * @param viewEngine The view engine to use during the load process.
    * @param compileInstruction Additional instructions to use during compilation of the view.
    * @param loadContext The loading context used for loading all resources and dependencies.
    * @param target A class from which to extract metadata of additional resources to load.
    * @return A promise for the view factory that is produced by this strategy.
    */
  loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext, target?: any): Promise<ViewFactory>;
}

/**
* A view strategy created directly from the template registry entry.
*/
export class TemplateRegistryViewStrategy {
  
  /**
    * Creates an instance of TemplateRegistryViewStrategy.
    * @param moduleId The associated moduleId of the view to be loaded.
    * @param entry The template registry entry used in loading the view factory.
    */
  constructor(moduleId: string, entry: TemplateRegistryEntry);
  
  /**
    * Loads a view factory.
    * @param viewEngine The view engine to use during the load process.
    * @param compileInstruction Additional instructions to use during compilation of the view.
    * @param loadContext The loading context used for loading all resources and dependencies.
    * @param target A class from which to extract metadata of additional resources to load.
    * @return A promise for the view factory that is produced by this strategy.
    */
  loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext, target?: any): Promise<ViewFactory>;
}

/**
* A view strategy that allows the component authore to inline the html for the view.
*/
export class InlineViewStrategy {
  
  /**
    * Creates an instance of InlineViewStrategy.
    * @param markup The markup for the view. Be sure to include the wrapping template tag.
    * @param dependencies A list of view resource dependencies of this view.
    * @param dependencyBaseUrl The base url for the view dependencies.
    */
  constructor(markup: string, dependencies?: Array<string | Function | Object>, dependencyBaseUrl?: string);
  
  /**
    * Loads a view factory.
    * @param viewEngine The view engine to use during the load process.
    * @param compileInstruction Additional instructions to use during compilation of the view.
    * @param loadContext The loading context used for loading all resources and dependencies.
    * @param target A class from which to extract metadata of additional resources to load.
    * @return A promise for the view factory that is produced by this strategy.
    */
  loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext, target?: any): Promise<ViewFactory>;
}

/**
* Locates a view for an object.
*/
export class ViewLocator {
  
  /**
    * The metadata key for storing/finding view strategies associated with an class/object.
    */
  static viewStrategyMetadataKey: any;
  
  /**
    * Gets the view strategy for the value.
    * @param value The value to locate the view strategy for.
    * @return The located ViewStrategy instance.
    */
  getViewStrategy(value: any): ViewStrategy;
  
  /**
    * Creates a fallback View Strategy. Used when unable to locate a configured strategy.
    * The default implementation returns and instance of ConventionalViewStrategy.
    * @param origin The origin of the view model to return the strategy for.
    * @return The fallback ViewStrategy.
    */
  createFallbackViewStrategy(origin: Origin): ViewStrategy;
  
  /**
    * Conventionally converts a view model origin to a view url.
    * Used by the ConventionalViewStrategy.
    * @param origin The origin of the view model to convert.
    * @return The view url.
    */
  convertOriginToViewUrl(origin: Origin): string;
}

/**
* An abstract base class for implementations of a binding language.
*/
export class BindingLanguage {
  
  /**
    * Inspects an attribute for bindings.
    * @param resources The ViewResources for the view being compiled.
    * @param elementName The element name to inspect.
    * @param attrName The attribute name to inspect.
    * @param attrValue The attribute value to inspect.
    * @return An info object with the results of the inspection.
    */
  inspectAttribute(resources: ViewResources, elementName: string, attrName: string, attrValue: string): Object;
  
  /**
    * Creates an attribute behavior instruction.
    * @param resources The ViewResources for the view being compiled.
    * @param element The element that the attribute is defined on.
    * @param info The info object previously returned from inspectAttribute.
    * @param existingInstruction A previously created instruction for this attribute.
    * @return The instruction instance.
    */
  createAttributeInstruction(resources: ViewResources, element: Element, info: Object, existingInstruction?: Object): BehaviorInstruction;
  
  /**
    * Parses the text for bindings.
    * @param resources The ViewResources for the view being compiled.
    * @param value The value of the text to parse.
    * @return A binding expression.
    */
  inspectTextContent(resources: ViewResources, value: string): Object;
}
export class SlotCustomAttribute {
  constructor(element?: any);
  valueChanged(newValue?: any, oldValue?: any): any;
}
export class PassThroughSlot {
  constructor(anchor?: any, name?: any, destinationName?: any, fallbackFactory?: any);
  needsFallbackRendering: any;
  renderFallbackContent(view?: any, nodes?: any, projectionSource?: any, index?: any): any;
  passThroughTo(destinationSlot?: any): any;
  addNode(view?: any, node?: any, projectionSource?: any, index?: any): any;
  removeView(view?: any, projectionSource?: any): any;
  removeAll(projectionSource?: any): any;
  projectFrom(view?: any, projectionSource?: any): any;
  created(ownerView?: any): any;
  bind(view?: any): any;
  attached(): any;
  detached(): any;
  unbind(): any;
}
export class ShadowSlot {
  constructor(anchor?: any, name?: any, fallbackFactory?: any);
  needsFallbackRendering: any;
  addNode(view?: any, node?: any, projectionSource?: any, index?: any, destination?: any): any;
  removeView(view?: any, projectionSource?: any): any;
  removeAll(projectionSource?: any): any;
  projectTo(slots?: any): any;
  projectFrom(view?: any, projectionSource?: any): any;
  renderFallbackContent(view?: any, nodes?: any, projectionSource?: any, index?: any): any;
  created(ownerView?: any): any;
  bind(view?: any): any;
  attached(): any;
  detached(): any;
  unbind(): any;
}
export class ShadowDOM {
  static defaultSlotKey: any;
  static getSlotName(node?: any): any;
  static distributeView(view?: any, slots?: any, projectionSource?: any, index?: any, destinationOverride?: any): any;
  static undistributeView(view?: any, slots?: any, projectionSource?: any): any;
  static undistributeAll(slots?: any, projectionSource?: any): any;
  static distributeNodes(view?: any, nodes?: any, slots?: any, projectionSource?: any, index?: any, destinationOverride?: any): any;
}

/**
* Represents a collection of resources used during the compilation of a view.
*/
/**
* Represents a collection of resources used during the compilation of a view.
*/
export class ViewResources {
  
  /**
    * A custom binding language used in the view.
    */
  bindingLanguage: any;
  
  /**
    * Creates an instance of ViewResources.
    * @param parent The parent resources. This resources can override them, but if a resource is not found, it will be looked up in the parent.
    * @param viewUrl The url of the view to which these resources apply.
    */
  constructor(parent?: ViewResources, viewUrl?: string);
  
  /**
    * Registers view engine hooks for the view.
    * @param hooks The hooks to register.
    */
  registerViewEngineHooks(hooks: ViewEngineHooks): void;
  
  /**
    * Gets the binding language associated with these resources, or return the provided fallback implementation.
    * @param bindingLanguageFallback The fallback binding language implementation to use if no binding language is configured locally.
    * @return The binding language.
    */
  getBindingLanguage(bindingLanguageFallback: BindingLanguage): BindingLanguage;
  
  /**
    * Patches an immediate parent into the view resource resolution hierarchy.
    * @param newParent The new parent resources to patch in.
    */
  patchInParent(newParent: ViewResources): void;
  
  /**
    * Maps a path relative to the associated view's origin.
    * @param path The relative path.
    * @return The calcualted path.
    */
  relativeToView(path: string): string;
  
  /**
    * Registers an HTML element.
    * @param tagName The name of the custom element.
    * @param behavior The behavior of the element.
    */
  registerElement(tagName: string, behavior: HtmlBehaviorResource): void;
  
  /**
    * Gets an HTML element behavior.
    * @param tagName The tag name to search for.
    * @return The HtmlBehaviorResource for the tag name or null.
    */
  getElement(tagName: string): HtmlBehaviorResource;
  
  /**
    * Gets the known attribute name based on the local attribute name.
    * @param attribute The local attribute name to lookup.
    * @return The known name.
    */
  mapAttribute(attribute: string): string;
  
  /**
    * Registers an HTML attribute.
    * @param attribute The name of the attribute.
    * @param behavior The behavior of the attribute.
    * @param knownAttribute The well-known name of the attribute (in lieu of the local name).
    */
  registerAttribute(attribute: string, behavior: HtmlBehaviorResource, knownAttribute: string): void;
  
  /**
    * Gets an HTML attribute behavior.
    * @param attribute The name of the attribute to lookup.
    * @return The HtmlBehaviorResource for the attribute or null.
    */
  getAttribute(attribute: string): HtmlBehaviorResource;
  
  /**
    * Registers a value converter.
    * @param name The name of the value converter.
    * @param valueConverter The value converter instance.
    */
  registerValueConverter(name: string, valueConverter: Object): void;
  
  /**
    * Gets a value converter.
    * @param name The name of the value converter.
    * @return The value converter instance.
    */
  getValueConverter(name: string): Object;
  
  /**
    * Registers a binding behavior.
    * @param name The name of the binding behavior.
    * @param bindingBehavior The binding behavior instance.
    */
  registerBindingBehavior(name: string, bindingBehavior: Object): void;
  
  /**
    * Gets a binding behavior.
    * @param name The name of the binding behavior.
    * @return The binding behavior instance.
    */
  getBindingBehavior(name: string): Object;
  
  /**
    * Registers a value.
    * @param name The name of the value.
    * @param value The value.
    */
  registerValue(name: string, value: any): void;
  
  /**
    * Gets a value.
    * @param name The name of the value.
    * @return The value.
    */
  getValue(name: string): any;
}
export class View {
  
  /**
    * The Dependency Injection Container that was used to create this View instance.
    */
  container: Container;
  
  /**
    * The ViewFactory that built this View instance.
    */
  viewFactory: ViewFactory;
  
  /**
    * Contains the DOM Nodes which represent this View. If the view was created via the "enhance" API, this will be an Element, otherwise it will be a DocumentFragment. If not created via "enhance" then the fragment will only contain nodes when the View is detached from the DOM.
    */
  fragment: DocumentFragment | Element;
  
  /**
    * The primary binding context that this view is data-bound to.
    */
  bindingContext: Object;
  
  /**
    * The override context which contains properties capable of overriding those found on the binding context.
    */
  overrideContext: Object;
  
  /**
    * Creates a View instance.
    * @param container The container from which the view was created.
    * @param viewFactory The factory that created this view.
    * @param fragment The DOM fragement representing the view.
    * @param controllers The controllers inside this view.
    * @param bindings The bindings inside this view.
    * @param children The children of this view.
    */
  constructor(container: Container, viewFactory: ViewFactory, fragment: DocumentFragment, controllers: Controller[], bindings: Binding[], children: ViewNode[], slots: Object);
  
  /**
    * Returns this view to the appropriate view cache.
    */
  returnToCache(): void;
  
  /**
    * Triggers the created callback for this view and its children.
    */
  created(): void;
  
  /**
    * Binds the view and it's children.
    * @param bindingContext The binding context to bind to.
    * @param overrideContext A secondary binding context that can override the standard context.
    */
  bind(bindingContext: Object, overrideContext?: Object, _systemUpdate?: boolean): void;
  
  /**
    * Adds a binding instance to this view.
    * @param binding The binding instance.
    */
  addBinding(binding: Object): void;
  
  /**
    * Unbinds the view and its children.
    */
  unbind(): void;
  
  /**
    * Inserts this view's nodes before the specified DOM node.
    * @param refNode The node to insert this view's nodes before.
    */
  insertNodesBefore(refNode: Node): void;
  
  /**
    * Appends this view's to the specified DOM node.
    * @param parent The parent element to append this view's nodes to.
    */
  appendNodesTo(parent: Element): void;
  
  /**
    * Removes this view's nodes from the DOM.
    */
  removeNodes(): void;
  
  /**
    * Triggers the attach for the view and its children.
    */
  attached(): void;
  
  /**
    * Triggers the detach for the view and its children.
    */
  detached(): void;
}

/**
* Represents a slot or location within the DOM to which views can be added and removed.
* Manages the view lifecycle for its children.
*/
export class ViewSlot {
  
  /**
    * Creates an instance of ViewSlot.
    * @param anchor The DOM node which will server as the anchor or container for insertion.
    * @param anchorIsContainer Indicates whether the node is a container.
    * @param animator The animator that will controll enter/leave transitions for this slot.
    */
  constructor(anchor: Node, anchorIsContainer: boolean, animator?: Animator);
  
  /**
     *   Runs the animator against the first animatable element found within the view's fragment
     *   @param  view       The view to use when searching for the element.
     *   @param  direction  The animation direction enter|leave.
     *   @returns An animation complete Promise or undefined if no animation was run.
     */
  animateView(view: View, direction?: string): void | Promise<any>;
  
  /**
    * Takes the child nodes of an existing element that has been converted into a ViewSlot
    * and makes those nodes into a View within the slot.
    */
  transformChildNodesIntoView(): void;
  
  /**
    * Binds the slot and it's children.
    * @param bindingContext The binding context to bind to.
    * @param overrideContext A secondary binding context that can override the standard context.
    */
  bind(bindingContext: Object, overrideContext: Object): void;
  
  /**
    * Unbinds the slot and its children.
    */
  unbind(): void;
  
  /**
    * Adds a view to the slot.
    * @param view The view to add.
    * @return May return a promise if the view addition triggered an animation.
    */
  add(view: View): void | Promise<any>;
  
  /**
    * Inserts a view into the slot.
    * @param index The index to insert the view at.
    * @param view The view to insert.
    * @return May return a promise if the view insertion triggered an animation.
    */
  insert(index: number, view: View): void | Promise<any>;
  
  /**
     * Moves a view across the slot.
     * @param sourceIndex The index the view is currently at.
     * @param targetIndex The index to insert the view at.
     */
  move(sourceIndex?: any, targetIndex?: any): any;
  
  /**
    * Removes a view from the slot.
    * @param view The view to remove.
    * @param returnToCache Should the view be returned to the view cache?
    * @param skipAnimation Should the removal animation be skipped?
    * @return May return a promise if the view removal triggered an animation.
    */
  remove(view: View, returnToCache?: boolean, skipAnimation?: boolean): void | Promise<View>;
  
  /**
    * Removes many views from the slot.
    * @param viewsToRemove The array of views to remove.
    * @param returnToCache Should the views be returned to the view cache?
    * @param skipAnimation Should the removal animation be skipped?
    * @return May return a promise if the view removal triggered an animation.
    */
  removeMany(viewsToRemove: View[], returnToCache?: boolean, skipAnimation?: boolean): void | Promise<View>;
  
  /**
    * Removes a view an a specified index from the slot.
    * @param index The index to remove the view at.
    * @param returnToCache Should the view be returned to the view cache?
    * @param skipAnimation Should the removal animation be skipped?
    * @return May return a promise if the view removal triggered an animation.
    */
  removeAt(index: number, returnToCache?: boolean, skipAnimation?: boolean): View | Promise<View>;
  
  /**
    * Removes all views from the slot.
    * @param returnToCache Should the view be returned to the view cache?
    * @param skipAnimation Should the removal animation be skipped?
    * @return May return a promise if the view removals triggered an animation.
    */
  removeAll(returnToCache?: boolean, skipAnimation?: boolean): void | Promise<any>;
  
  /**
    * Triggers the attach for the slot and its children.
    */
  attached(): void;
  
  /**
    * Triggers the detach for the slot and its children.
    */
  detached(): void;
  projectTo(slots: Object): void;
}

/**
* A factory capable of creating View instances, bound to a location within another view hierarchy.
*/
export class BoundViewFactory {
  
  /**
    * Creates an instance of BoundViewFactory.
    * @param parentContainer The parent DI container.
    * @param viewFactory The internal unbound factory.
    * @param partReplacements Part replacement overrides for the internal factory.
    */
  constructor(parentContainer: Container, viewFactory: ViewFactory, partReplacements?: Object);
  
  /**
    * Creates a view or returns one from the internal cache, if available.
    * @return The created view.
    */
  create(): View;
  
  /**
    * Indicates whether this factory is currently using caching.
    */
  isCaching: any;
  
  /**
    * Sets the cache size for this factory.
    * @param size The number of views to cache or "*" to cache all.
    * @param doNotOverrideIfAlreadySet Indicates that setting the cache should not override the setting if previously set.
    */
  setCacheSize(size: number | string, doNotOverrideIfAlreadySet: boolean): void;
  
  /**
    * Gets a cached view if available...
    * @return A cached view or null if one isn't available.
    */
  getCachedView(): View;
  
  /**
    * Returns a view to the cache.
    * @param view The view to return to the cache if space is available.
    */
  returnViewToCache(view: View): void;
}

/**
* A factory capable of creating View instances.
*/
export class ViewFactory {
  
  /**
    * Indicates whether this factory is currently using caching.
    */
  isCaching: any;
  
  /**
    * Creates an instance of ViewFactory.
    * @param template The document fragment that serves as a template for the view to be created.
    * @param instructions The instructions to be applied ot the template during the creation of a view.
    * @param resources The resources used to compile this factory.
    */
  constructor(template: DocumentFragment, instructions: Object, resources: ViewResources);
  
  /**
    * Sets the cache size for this factory.
    * @param size The number of views to cache or "*" to cache all.
    * @param doNotOverrideIfAlreadySet Indicates that setting the cache should not override the setting if previously set.
    */
  setCacheSize(size: number | string, doNotOverrideIfAlreadySet: boolean): void;
  
  /**
    * Gets a cached view if available...
    * @return A cached view or null if one isn't available.
    */
  getCachedView(): View;
  
  /**
    * Returns a view to the cache.
    * @param view The view to return to the cache if space is available.
    */
  returnViewToCache(view: View): void;
  
  /**
    * Creates a view or returns one from the internal cache, if available.
    * @param container The container to create the view from.
    * @param createInstruction The instruction used to customize view creation.
    * @param element The custom element that hosts the view.
    * @return The created view.
    */
  create(container: Container, createInstruction?: ViewCreateInstruction, element?: Element): View;
}

/**
* Compiles html templates, dom fragments and strings into ViewFactory instances, capable of instantiating Views.
*/
export class ViewCompiler {
  
  /**
    * Creates an instance of ViewCompiler.
    * @param bindingLanguage The default data binding language and syntax used during view compilation.
    * @param resources The global resources used during compilation when none are provided for compilation.
    */
  constructor(bindingLanguage: BindingLanguage, resources: ViewResources);
  
  /**
    * Compiles an html template, dom fragment or string into ViewFactory instances, capable of instantiating Views.
    * @param source The template, fragment or string to compile.
    * @param resources The view resources used during compilation.
    * @param compileInstruction A set of instructions that customize how compilation occurs.
    * @return The compiled ViewFactory.
    */
  compile(source: Element | DocumentFragment | string, resources?: ViewResources, compileInstruction?: ViewCompileInstruction): ViewFactory;
}

/**
* Represents a module with view resources.
*/
export class ResourceModule {
  
  /**
    * Creates an instance of ResourceModule.
    * @param moduleId The id of the module that contains view resources.
    */
  constructor(moduleId: string);
  
  /**
    * Initializes the resources within the module.
    * @param container The dependency injection container usable during resource initialization.
    */
  initialize(container: Container): void;
  
  /**
    * Registers the resources in the module with the view resources.
    * @param registry The registry of view resources to regiser within.
    * @param name The name to use in registering the default resource.
    */
  register(registry: ViewResources, name?: string): void;
  
  /**
    * Loads any dependencies of the resources within this module.
    * @param container The DI container to use during dependency resolution.
    * @param loadContext The loading context used for loading all resources and dependencies.
    * @return A promise that resolves when all loading is complete.
    */
  load(container: Container, loadContext?: ResourceLoadContext): Promise<void>;
}

/**
* Represents a single view resource with a ResourceModule.
*/
export class ResourceDescription {
  
  /**
    * Creates an instance of ResourceDescription.
    * @param key The key that the resource was exported as.
    * @param exportedValue The exported resource.
    * @param resourceTypeMeta The metadata located on the resource.
    */
  constructor(key: string, exportedValue: any, resourceTypeMeta?: Object);
  
  /**
    * Initializes the resource.
    * @param container The dependency injection container usable during resource initialization.
    */
  initialize(container: Container): void;
  
  /**
    * Registrers the resource with the view resources.
    * @param registry The registry of view resources to regiser within.
    * @param name The name to use in registering the resource.
    */
  register(registry: ViewResources, name?: string): void;
  
  /**
    * Loads any dependencies of the resource.
    * @param container The DI container to use during dependency resolution.
    * @param loadContext The loading context used for loading all resources and dependencies.
    * @return A promise that resolves when all loading is complete.
    */
  load(container: Container, loadContext?: ResourceLoadContext): Promise<void> | void;
}

/**
* Analyzes a module in order to discover the view resources that it exports.
*/
export class ModuleAnalyzer {
  
  /**
    * Creates an instance of ModuleAnalyzer.
    */
  constructor();
  
  /**
    * Retrieves the ResourceModule analysis for a previously analyzed module.
    * @param moduleId The id of the module to lookup.
    * @return The ResouceModule if found, undefined otherwise.
    */
  getAnalysis(moduleId: string): ResourceModule;
  
  /**
    * Analyzes a module.
    * @param moduleId The id of the module to analyze.
    * @param moduleInstance The module instance to analyze.
    * @param mainResourceKey The name of the main resource.
    * @return The ResouceModule representing the analysis.
    */
  analyze(moduleId: string, moduleInstance: any, mainResourceKey?: string): ResourceModule;
}

/**
* Controls the view resource loading pipeline.
*/
export class ViewEngine {
  
  /**
    * The metadata key for storing requires declared in a ViewModel.
    */
  static viewModelRequireMetadataKey: any;
  
  /**
    * Creates an instance of ViewEngine.
    * @param loader The module loader.
    * @param container The root DI container for the app.
    * @param viewCompiler The view compiler.
    * @param moduleAnalyzer The module analyzer.
    * @param appResources The app-level global resources.
    */
  constructor(loader: Loader, container: Container, viewCompiler: ViewCompiler, moduleAnalyzer: ModuleAnalyzer, appResources: ViewResources);
  
  /**
    * Adds a resource plugin to the resource loading pipeline.
    * @param extension The file extension to match in require elements.
    * @param implementation The plugin implementation that handles the resource type.
    */
  addResourcePlugin(extension: string, implementation: Object): void;
  
  /**
    * Loads and compiles a ViewFactory from a url or template registry entry.
    * @param urlOrRegistryEntry A url or template registry entry to generate the view factory for.
    * @param compileInstruction Instructions detailing how the factory should be compiled.
    * @param loadContext The load context if this factory load is happening within the context of a larger load operation.
    * @param target A class from which to extract metadata of additional resources to load.
    * @return A promise for the compiled view factory.
    */
  loadViewFactory(urlOrRegistryEntry: string | TemplateRegistryEntry, compileInstruction?: ViewCompileInstruction, loadContext?: ResourceLoadContext, target?: any): Promise<ViewFactory>;
  
  /**
    * Loads all the resources specified by the registry entry.
    * @param registryEntry The template registry entry to load the resources for.
    * @param compileInstruction The compile instruction associated with the load.
    * @param loadContext The load context if this is happening within the context of a larger load operation.
    * @param target A class from which to extract metadata of additional resources to load.
    * @return A promise of ViewResources for the registry entry.
    */
  loadTemplateResources(registryEntry: TemplateRegistryEntry, compileInstruction?: ViewCompileInstruction, loadContext?: ResourceLoadContext, target?: any): Promise<ViewResources>;
  
  /**
    * Loads a view model as a resource.
    * @param moduleImport The module to import.
    * @param moduleMember The export from the module to generate the resource for.
    * @return A promise for the ResourceDescription.
    */
  importViewModelResource(moduleImport: string, moduleMember: string): Promise<ResourceDescription>;
  
  /**
    * Imports the specified resources with the specified names into the view resources object.
    * @param moduleIds The modules to load.
    * @param names The names associated with resource modules to import.
    * @param resources The resources lookup to add the loaded resources to.
    * @param compileInstruction The compilation instruction associated with the resource imports.
    * @return A promise for the ViewResources.
    */
  importViewResources(moduleIds: string[], names: string[], resources: ViewResources, compileInstruction?: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewResources>;
}

/**
* Controls a view model (and optionally its view), according to a particular behavior and by following a set of instructions.
*/
export class Controller {
  
  /**
    * The HtmlBehaviorResource that provides the base behavior for this controller.
    */
  behavior: HtmlBehaviorResource;
  
  /**
    * The developer's view model instance which provides the custom behavior for this controller.
    */
  viewModel: Object;
  
  /**
    * The view associated with the component being controlled by this controller.
    * Note: Not all components will have a view, so the value may be null.
    */
  view: View;
  
  /**
    * Creates an instance of Controller.
    * @param behavior The HtmlBehaviorResource that provides the base behavior for this controller.
    * @param instruction The instructions pertaining to the controller's behavior.
    * @param viewModel The developer's view model instance which provides the custom behavior for this controller.
    * @param container The container that the controller's view was created from.
    */
  constructor(behavior: HtmlBehaviorResource, instruction: BehaviorInstruction, viewModel: Object, container: Container);
  
  /**
    * Invoked when the view which contains this controller is created.
    * @param owningView The view inside which this controller resides.
    */
  created(owningView: View): void;
  
  /**
    * Used to automate the proper binding of this controller and its view. Used by the composition engine for dynamic component creation.
    * This should be considered a semi-private API and is subject to change without notice, even across minor or patch releases.
    * @param overrideContext An override context for binding.
    * @param owningView The view inside which this controller resides.
    */
  automate(overrideContext?: Object, owningView?: View): void;
  
  /**
    * Binds the controller to the scope.
    * @param scope The binding scope.
    */
  bind(scope: Object): void;
  
  /**
    * Unbinds the controller.
    */
  unbind(): void;
  
  /**
    * Attaches the controller.
    */
  attached(): void;
  
  /**
    * Detaches the controller.
    */
  detached(): void;
}

/**
* An implementation of Aurelia's Observer interface that is used to back bindable properties defined on a behavior.
*/
export class BehaviorPropertyObserver {
  
  /**
    * Creates an instance of BehaviorPropertyObserver.
    * @param taskQueue The task queue used to schedule change notifications.
    * @param obj The object that the property is defined on.
    * @param propertyName The name of the property.
    * @param selfSubscriber The callback function that notifies the object which defines the properties, if present.
    * @param initialValue The initial value of the property.
    */
  constructor(taskQueue: TaskQueue, obj: Object, propertyName: string, selfSubscriber: Function, initialValue: any);
  
  /**
    * Gets the property's value.
    */
  getValue(): any;
  
  /**
    * Sets the property's value.
    * @param newValue The new value to set.
    */
  setValue(newValue: any): void;
  
  /**
    * Invoked by the TaskQueue to publish changes to subscribers.
    */
  call(): void;
  
  /**
    * Subscribes to the observerable.
    * @param context A context object to pass along to the subscriber when it's called.
    * @param callable A function or object with a "call" method to be invoked for delivery of changes.
    */
  subscribe(context: any, callable: Function): void;
  
  /**
    * Unsubscribes from the observerable.
    * @param context The context object originally subscribed with.
    * @param callable The callable that was originally subscribed with.
    */
  unsubscribe(context: any, callable: Function): void;
}

/**
* Represents a bindable property on a behavior.
*/
export class BindableProperty {
  
  /**
    * Creates an instance of BindableProperty.
    * @param nameOrConfig The name of the property or a cofiguration object.
    */
  constructor(nameOrConfig: string | Object);
  
  /**
    * Registers this bindable property with particular Class and Behavior instance.
    * @param target The class to register this behavior with.
    * @param behavior The behavior instance to register this property with.
    * @param descriptor The property descriptor for this property.
    */
  registerWith(target: Function, behavior: HtmlBehaviorResource, descriptor?: Object): void;
  
  /**
    * Defines this property on the specified class and behavior.
    * @param target The class to define the property on.
    * @param behavior The behavior to define the property on.
    */
  defineOn(target: Function, behavior: HtmlBehaviorResource): void;
  
  /**
    * Creates an observer for this property.
    * @param viewModel The view model instance on which to create the observer.
    * @return The property observer.
    */
  createObserver(viewModel: Object): BehaviorPropertyObserver;
}

/**
* Identifies a class as a resource that implements custom element or custom
* attribute functionality.
*/
export class HtmlBehaviorResource {
  
  /**
    * Creates an instance of HtmlBehaviorResource.
    */
  constructor();
  
  /**
    * Checks whether the provided name matches any naming conventions for HtmlBehaviorResource.
    * @param name The name of the potential resource.
    * @param existing An already existing resource that may need a convention name applied.
    */
  static convention(name: string, existing?: HtmlBehaviorResource): HtmlBehaviorResource;
  
  /**
    * Adds a binding expression to the component created by this resource.
    * @param behavior The binding expression.
    */
  addChildBinding(behavior: Object): void;
  
  /**
    * Provides an opportunity for the resource to initialize iteself.
    * @param container The dependency injection container from which the resource
    * can aquire needed services.
    * @param target The class to which this resource metadata is attached.
    */
  initialize(container: Container, target: Function): void;
  
  /**
    * Allows the resource to be registered in the view resources for the particular
    * view into which it was required.
    * @param registry The view resource registry for the view that required this resource.
    * @param name The name provided by the end user for this resource, within the
    * particular view it's being used.
    */
  register(registry: ViewResources, name?: string): void;
  
  /**
    * Enables the resource to asynchronously load additional resources.
    * @param container The dependency injection container from which the resource
    * can aquire needed services.
    * @param target The class to which this resource metadata is attached.
    * @param loadContext The loading context object provided by the view engine.
    * @param viewStrategy A view strategy to overload the default strategy defined by the resource.
    * @param transientView Indicated whether the view strategy is transient or
    * permanently tied to this component.
    */
  load(container: Container, target: Function, loadContext?: ResourceLoadContext, viewStrategy?: ViewStrategy, transientView?: boolean): Promise<HtmlBehaviorResource>;
  
  /**
    * Plugs into the compiler and enables custom processing of the node on which this behavior is located.
    * @param compiler The compiler that is currently compiling the view that this behavior exists within.
    * @param resources The resources for the view that this behavior exists within.
    * @param node The node on which this behavior exists.
    * @param instruction The behavior instruction created for this behavior.
    * @param parentNode The parent node of the current node.
    * @return The current node.
    */
  compile(compiler: ViewCompiler, resources: ViewResources, node: Node, instruction: BehaviorInstruction, parentNode?: Node): Node;
  
  /**
    * Creates an instance of this behavior.
    * @param container The DI container to create the instance in.
    * @param instruction The instruction for this behavior that was constructed during compilation.
    * @param element The element on which this behavior exists.
    * @param bindings The bindings that are associated with the view in which this behavior exists.
    * @return The Controller of this behavior.
    */
  create(container: Container, instruction?: BehaviorInstruction, element?: Element, bindings?: Binding[]): Controller;
}

/**
* Creates a behavior property that references an array of immediate content child elements that matches the provided selector.
*/
export function children(selectorOrConfig: string | Object): any;

/**
* Creates a behavior property that references an immediate content child element that matches the provided selector.
*/
export function child(selectorOrConfig: string | Object): any;
export const SwapStrategies: any;

/**
* Used to dynamically compose components.
*/
export class CompositionEngine {
  
  /**
    * Creates an instance of the CompositionEngine.
    * @param viewEngine The ViewEngine used during composition.
    */
  constructor(viewEngine: ViewEngine, viewLocator: ViewLocator);
  
  /**
    * Creates a controller instance for the component described in the context.
    * @param context The CompositionContext that describes the component.
    * @return A Promise for the Controller.
    */
  createController(context: CompositionContext): Promise<Controller>;
  
  /**
    * Ensures that the view model and its resource are loaded for this context.
    * @param context The CompositionContext to load the view model and its resource for.
    * @return A Promise for the context.
    */
  ensureViewModel(context: CompositionContext): Promise<CompositionContext>;
  
  /**
    * Dynamically composes a component.
    * @param context The CompositionContext providing information on how the composition should occur.
    * @return A Promise for the View or the Controller that results from the dynamic composition.
    */
  compose(context: CompositionContext): Promise<View | Controller>;
}

/**
* Identifies a class as a resource that configures the EventManager with information
* about how events relate to properties for the purpose of two-way data-binding
* to Web Components.
*/
export class ElementConfigResource {
  
  /**
    * Provides an opportunity for the resource to initialize iteself.
    * @param container The dependency injection container from which the resource
    * can aquire needed services.
    * @param target The class to which this resource metadata is attached.
    */
  initialize(container: Container, target: Function): void;
  
  /**
    * Allows the resource to be registered in the view resources for the particular
    * view into which it was required.
    * @param registry The view resource registry for the view that required this resource.
    * @param name The name provided by the end user for this resource, within the
    * particular view it's being used.
    */
  register(registry: ViewResources, name?: string): void;
  
  /**
    * Enables the resource to asynchronously load additional resources.
    * @param container The dependency injection container from which the resource
    * can aquire needed services.
    * @param target The class to which this resource metadata is attached.
    */
  load(container: Container, target: Function): void;
}

/**
* Decorator: Specifies a resource instance that describes the decorated class.
* @param instance The resource instance.
*/
export function resource(instance: Object): any;

/**
* Decorator: Specifies a custom HtmlBehaviorResource instance or an object that overrides various implementation details of the default HtmlBehaviorResource.
* @param override The customized HtmlBehaviorResource or an object to override the default with.
*/
export function behavior(override: HtmlBehaviorResource | Object): any;

/**
* Decorator: Indicates that the decorated class is a custom element.
* @param name The name of the custom element.
*/
export function customElement(name: string): any;

/**
* Decorator: Indicates that the decorated class is a custom attribute.
* @param name The name of the custom attribute.
* @param defaultBindingMode The default binding mode to use when the attribute is bound with .bind.
* @param aliases The array of aliases to associate to the custom attribute.
*/
export function customAttribute(name: string, defaultBindingMode?: number, aliases?: string[]): any;

/**
* Decorator: Applied to custom attributes. Indicates that whatever element the
* attribute is placed on should be converted into a template and that this
* attribute controls the instantiation of the template.
*/
export function templateController(target?: any): any;

/**
* Decorator: Specifies that a property is bindable through HTML.
* @param nameOrConfigOrTarget The name of the property, or a configuration object.
*/
export function bindable(nameOrConfigOrTarget?: string | Object, key?: any, descriptor?: any): any;

/**
* Decorator: Specifies that the decorated custom attribute has options that
* are dynamic, based on their presence in HTML and not statically known.
*/
export function dynamicOptions(target?: any): any;

/**
* Decorator: Indicates that the custom element should render its view in Shadow
* DOM. This decorator may change slightly when Aurelia updates to Shadow DOM v1.
*/
export function useShadowDOM(targetOrOptions?: any): any;

/**
* Decorator: Enables custom processing of the attributes on an element before the framework inspects them.
* @param processor Pass a function which can provide custom processing of the content.
*/
export function processAttributes(processor: Function): any;

/**
* Decorator: Enables custom processing of the content that is places inside the
* custom element by its consumer.
* @param processor Pass a boolean to direct the template compiler to not process
* the content placed inside this element. Alternatively, pass a function which
* can provide custom processing of the content. This function should then return
* a boolean indicating whether the compiler should also process the content.
*/
export function processContent(processor: boolean | Function): any;

/**
* Decorator: Indicates that the custom element should be rendered without its
* element container.
*/
export function containerless(target?: any): any;

/**
* Decorator: Associates a custom view strategy with the component.
* @param strategy The view strategy instance.
*/
export function useViewStrategy(strategy: Object): any;

/**
* Decorator: Provides a relative path to a view for the component.
* @param path The path to the view.
*/
export function useView(path: string): any;

/**
* Decorator: Provides a view template, directly inline, for the component. Be
* sure to wrap the markup in a template element.
* @param markup The markup for the view.
* @param dependencies A list of dependencies that the template has.
* @param dependencyBaseUrl A base url from which the dependencies will be loaded.
*/
export function inlineView(markup: string, dependencies?: Array<string | Function | Object>, dependencyBaseUrl?: string): any;

/**
* Decorator: Indicates that the component has no view.
*/
export function noView(targetOrDependencies?: Function | Array<any>, dependencyBaseUrl?: string): any;

/**
* Decorator: Indicates that the decorated class provides element configuration
* to the EventManager for one or more Web Components.
*/
export function elementConfig(target?: any): any;

/**
* Decorator: Provides the ability to add resources to the related View
* Same as: <require from="..."></require>
* @param resources Either: strings with moduleIds, Objects with 'src' and optionally 'as' properties or one of the classes of the module to be included.
*/
export function viewResources(...resources: any[]): any;

/**
* A facade of the templating engine capabilties which provides a more user friendly API for common use cases.
*/

/**
* A facade of the templating engine capabilties which provides a more user friendly API for common use cases.
*/
export class TemplatingEngine {
  
  /**
    * Creates an instance of TemplatingEngine.
    * @param container The root DI container.
    * @param moduleAnalyzer The module analyzer for discovering view resources.
    * @param viewCompiler The view compiler for compiling views.
    * @param compositionEngine The composition engine used during dynamic component composition.
    */
  constructor(container: Container, moduleAnalyzer: ModuleAnalyzer, viewCompiler: ViewCompiler, compositionEngine: CompositionEngine);
  
  /**
     * Configures the default animator.
     * @param animator The animator instance.
     */
  configureAnimator(animator: Animator): void;
  
  /**
     * Dynamically composes components and views.
     * @param context The composition context to use.
     * @return A promise for the resulting Controller or View. Consumers of this API
     * are responsible for enforcing the Controller/View lifecycle.
     */
  compose(context: CompositionContext): Promise<View | Controller>;
  
  /**
     * Enhances existing DOM with behaviors and bindings.
     * @param instruction The element to enhance or a set of instructions for the enhancement process.
     * @return A View representing the enhanced UI. Consumers of this API
     * are responsible for enforcing the View lifecycle.
     */
  enhance(instruction: Element | EnhanceInstruction): View;
}
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dialog/master/dist/commonjs/attach-focus.d.ts
declare module '~aurelia-dialog/dist/commonjs/attach-focus' {
import { ComponentAttached } from '~aurelia-dialog~aurelia-templating/dist/aurelia-templating';
export class AttachFocus implements ComponentAttached {
    private element;
    value: boolean | string;
    constructor(element: HTMLElement);
    attached(): void;
    valueChanged(newValue: string): void;
}
}
declare module 'aurelia-dialog/dist/commonjs/attach-focus' {
export * from '~aurelia-dialog/dist/commonjs/attach-focus';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dialog/master/dist/commonjs/interfaces.d.ts
declare module '~aurelia-dialog/dist/commonjs/interfaces' {
/**
 * An optional interface describing the dialog canActivate convention.
 */
export interface DialogComponentCanActivate<T> {
    /**
     * Implement this hook if you want to control whether or not the dialog can be open.
     * To cancel the opening of the dialog return false or a promise that resolves to false.
     * Any other returned value is coerced to true.
     */
    canActivate(model?: T): boolean | Promise<boolean> | PromiseLike<boolean>;
}
/**
 * An optional interface describing the dialog activate convention.
 */
export interface DialogComponentActivate<T> {
    /**
     * Implement this hook if you want to perform custom logic just before the dialog is open.
     */
    activate(model?: T): void | Promise<void> | PromiseLike<void>;
}
/**
 * An optional interface describing the dialog canDeactivate convention.
 */
export interface DialogComponentCanDeactivate {
    /**
     * Implement this hook if you want to control whether or not the dialog can be closed.
     * To cancel the closing of the dialog return false or a promise that resolves to false.
     * Any other returned value is coerced to true.
     */
    canDeactivate(): boolean | Promise<boolean> | PromiseLike<boolean>;
}
/**
 * An optional interface describing the dialog deactivate convention.
 */
export interface DialogComponentDeactivate {
    /**
     * Implement this hook if you want to perform custom logic when the dialog is being closed.
     */
    deactivate(): void | Promise<void> | PromiseLike<void>;
}
}
declare module 'aurelia-dialog/dist/commonjs/interfaces' {
export * from '~aurelia-dialog/dist/commonjs/interfaces';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dependency-injection/master/dist/aurelia-dependency-injection.d.ts
declare module '~aurelia-dialog~aurelia-dependency-injection/dist/aurelia-dependency-injection' {
/**
* Decorator: Indicates that the decorated class/object is a custom resolver.
*/
export const resolver: Function & {
    decorates?: any;
};
/**
* Used to allow functions/classes to specify custom dependency resolution logic.
*/
export interface Resolver {
    /**
    * Called by the container to allow custom resolution of dependencies for a function/class.
    * @param container The container to resolve from.
    * @param key The key that the resolver was registered as.
    * @return Returns the resolved object.
    */
    get(container: Container, key: any): any;
}
/**
* Used to allow functions/classes to specify lazy resolution logic.
*/
export class Lazy {
    /**
    * Creates an instance of the Lazy class.
    * @param key The key to lazily resolve.
    */
    constructor(key: any);
    /**
    * Called by the container to lazily resolve the dependency into a lazy locator function.
    * @param container The container to resolve from.
    * @return Returns a function which can be invoked at a later time to obtain the actual dependency.
    */
    get(container: Container): any;
    /**
    * Creates a Lazy Resolver for the supplied key.
    * @param key The key to lazily resolve.
    * @return Returns an instance of Lazy for the key.
    */
    static of(key: any): Lazy;
}
/**
* Used to allow functions/classes to specify resolution of all matches to a key.
*/
export class All {
    /**
    * Creates an instance of the All class.
    * @param key The key to lazily resolve all matches for.
    */
    constructor(key: any);
    /**
    * Called by the container to resolve all matching dependencies as an array of instances.
    * @param container The container to resolve from.
    * @return Returns an array of all matching instances.
    */
    get(container: Container): any[];
    /**
    * Creates an All Resolver for the supplied key.
    * @param key The key to resolve all instances for.
    * @return Returns an instance of All for the key.
    */
    static of(key: any): All;
}
/**
* Used to allow functions/classes to specify an optional dependency, which will be resolved only if already registred with the container.
*/
export class Optional {
    /**
    * Creates an instance of the Optional class.
    * @param key The key to optionally resolve for.
    * @param checkParent Indicates whether or not the parent container hierarchy should be checked.
    */
    constructor(key: any, checkParent?: boolean);
    /**
    * Called by the container to provide optional resolution of the key.
    * @param container The container to resolve from.
    * @return Returns the instance if found; otherwise null.
    */
    get(container: Container): any;
    /**
    * Creates an Optional Resolver for the supplied key.
    * @param key The key to optionally resolve for.
    * @param [checkParent=true] Indicates whether or not the parent container hierarchy should be checked.
    * @return Returns an instance of Optional for the key.
    */
    static of(key: any, checkParent?: boolean): Optional;
}
/**
* Used to inject the dependency from the parent container instead of the current one.
*/
export class Parent {
    /**
    * Creates an instance of the Parent class.
    * @param key The key to resolve from the parent container.
    */
    constructor(key: any);
    /**
    * Called by the container to load the dependency from the parent container
    * @param container The container to resolve the parent from.
    * @return Returns the matching instance from the parent container
    */
    get(container: Container): any;
    /**
    * Creates a Parent Resolver for the supplied key.
    * @param key The key to resolve.
    * @return Returns an instance of Parent for the key.
    */
    static of(key: any): Parent;
}
export class StrategyResolver {
    strategy: StrategyResolver | number;
    state: any;
    /**
    * Creates an instance of the StrategyResolver class.
    * @param strategy The type of resolution strategy.
    * @param state The state associated with the resolution strategy.
    */
    constructor(strategy: any, state: any);
    /**
    * Called by the container to allow custom resolution of dependencies for a function/class.
    * @param container The container to resolve from.
    * @param key The key that the resolver was registered as.
    * @return Returns the resolved object.
    */
    get(container: Container, key: any): any;
}
/**
* Used to allow injecting dependencies but also passing data to the constructor.
*/
export class Factory {
    /**
    * Creates an instance of the Factory class.
    * @param key The key to resolve from the parent container.
    */
    constructor(key: any);
    /**
    * Called by the container to pass the dependencies to the constructor.
    * @param container The container to invoke the constructor with dependencies and other parameters.
    * @return Returns a function that can be invoked to resolve dependencies later, and the rest of the parameters.
    */
    get(container: Container): any;
    /**
    * Creates a Factory Resolver for the supplied key.
    * @param key The key to resolve.
    * @return Returns an instance of Factory for the key.
    */
    static of(key: any): Factory;
}
/**
* Used to inject a new instance of a dependency, without regard for existing
* instances in the container. Instances can optionally be registered in the container
* under a different key by supplying a key using the `as` method.
*/
export class NewInstance {
    key: any;
    asKey: any;
    /**
    * Creates an instance of the NewInstance class.
    * @param key The key to resolve/instantiate.
    * @param dynamicDependencies An optional list of dynamic dependencies.
    */
    constructor(key: any, ...dynamicDependencies: any[]);
    /**
    * Called by the container to instantiate the dependency and potentially register
    * as another key if the `as` method was used.
    * @param container The container to resolve the parent from.
    * @return Returns the matching instance from the parent container
    */
    get(container: any): any;
    /**
    * Instructs the NewInstance resolver to register the resolved instance using the supplied key.
    * @param key The key to register the instance with.
    * @return Returns the NewInstance resolver.
    */
    as(key: any): this;
    /**
    * Creates an NewInstance Resolver for the supplied key.
    * @param key The key to resolve/instantiate.
    * @param dynamicDependencies An optional list of dynamic dependencies.
    * @return Returns an instance of NewInstance for the key.
    */
    static of(key: any, ...dynamicDependencies: any[]): NewInstance;
}
export function getDecoratorDependencies(target: any, name: any): any;
/**
* Decorator: Specifies the dependency should be lazy loaded
*/
export function lazy(keyValue: any): (target: any, key: any, index: any) => void;
/**
* Decorator: Specifies the dependency should load all instances of the given key.
*/
export function all(keyValue: any): (target: any, key: any, index: any) => void;
/**
* Decorator: Specifies the dependency as optional
*/
export function optional(checkParentOrTarget?: boolean): (target: any, key: any, index: any) => void;
/**
* Decorator: Specifies the dependency to look at the parent container for resolution
*/
export function parent(target: any, key: any, index: any): void;
/**
* Decorator: Specifies the dependency to create a factory method, that can accept optional arguments
*/
export function factory(keyValue: any, asValue?: any): (target: any, key: any, index: any) => void;
/**
* Decorator: Specifies the dependency as a new instance
*/
export function newInstance(asKeyOrTarget?: any, ...dynamicDependencies: any[]): (target: any, key: any, index: any) => void;
/**
* Decorator: Specifies a custom Invoker for the decorated item.
*/
export function invoker(value: Invoker): any;
/**
* Decorator: Specifies that the decorated item should be called as a factory function, rather than a constructor.
*/
export function invokeAsFactory(potentialTarget?: any): any;
/**
* A strategy for invoking a function, resulting in an object instance.
*/
export interface Invoker {
    /**
    * Invokes the function with the provided dependencies.
    * @param fn The constructor or factory function.
    * @param dependencies The dependencies of the function call.
    * @return The result of the function invocation.
    */
    invoke(container: Container, fn: Function, dependencies: any[]): any;
    /**
    * Invokes the function with the provided dependencies.
    * @param fn The constructor or factory function.
    * @param staticDependencies The static dependencies of the function.
    * @param dynamicDependencies Additional dependencies to use during invocation.
    * @return The result of the function invocation.
    */
    invokeWithDynamicDependencies(container: Container, fn: Function, staticDependencies: any[], dynamicDependencies: any[]): any;
}
/**
* An Invoker that is used to invoke a factory method.
*/
export class FactoryInvoker {
    /**
    * The singleton instance of the FactoryInvoker.
    */
    static instance: FactoryInvoker;
    /**
    * Invokes the function with the provided dependencies.
    * @param container The calling container.
    * @param fn The constructor or factory function.
    * @param dependencies The dependencies of the function call.
    * @return The result of the function invocation.
    */
    invoke(container: Container, fn: Function, dependencies: any[]): any;
    /**
    * Invokes the function with the provided dependencies.
    * @param container The calling container.
    * @param fn The constructor or factory function.
    * @param staticDependencies The static dependencies of the function.
    * @param dynamicDependencies Additional dependencies to use during invocation.
    * @return The result of the function invocation.
    */
    invokeWithDynamicDependencies(container: Container, fn: Function, staticDependencies: any[], dynamicDependencies: any[]): any;
}
/**
* Decorator: Specifies a custom registration strategy for the decorated class/function.
*/
export function registration(value: Registration): any;
/**
* Decorator: Specifies to register the decorated item with a "transient" lifetime.
*/
export function transient(key?: any): any;
/**
* Decorator: Specifies to register the decorated item with a "singleton" lifetime.
*/
export function singleton(keyOrRegisterInChild?: any, registerInChild?: boolean): any;
/**
* Customizes how a particular function is resolved by the Container.
*/
export interface Registration {
    /**
    * Called by the container to register the resolver.
    * @param container The container the resolver is being registered with.
    * @param key The key the resolver should be registered as.
    * @param fn The function to create the resolver for.
    * @return The resolver that was registered.
    */
    registerResolver(container: Container, key: any, fn: Function): Resolver;
}
/**
* Used to allow functions/classes to indicate that they should be registered as transients with the container.
*/
export class TransientRegistration {
    /**
    * Creates an instance of TransientRegistration.
    * @param key The key to register as.
    */
    constructor(key?: any);
    /**
    * Called by the container to register the resolver.
    * @param container The container the resolver is being registered with.
    * @param key The key the resolver should be registered as.
    * @param fn The function to create the resolver for.
    * @return The resolver that was registered.
    */
    registerResolver(container: Container, key: any, fn: Function): Resolver;
}
/**
* Used to allow functions/classes to indicate that they should be registered as singletons with the container.
*/
export class SingletonRegistration {
    /**
    * Creates an instance of SingletonRegistration.
    * @param key The key to register as.
    */
    constructor(keyOrRegisterInChild?: any, registerInChild?: boolean);
    /**
    * Called by the container to register the resolver.
    * @param container The container the resolver is being registered with.
    * @param key The key the resolver should be registered as.
    * @param fn The function to create the resolver for.
    * @return The resolver that was registered.
    */
    registerResolver(container: Container, key: any, fn: Function): Resolver;
}
export const _emptyParameters: any[];
/**
* Stores the information needed to invoke a function.
*/
export class InvocationHandler {
    /**
    * The function to be invoked by this handler.
    */
    fn: Function;
    /**
    * The invoker implementation that will be used to actually invoke the function.
    */
    invoker: Invoker;
    /**
    * The statically known dependencies of this function invocation.
    */
    dependencies: any[];
    /**
    * Instantiates an InvocationDescription.
    * @param fn The Function described by this description object.
    * @param invoker The strategy for invoking the function.
    * @param dependencies The static dependencies of the function call.
    */
    constructor(fn: Function, invoker: Invoker, dependencies: any[]);
    /**
    * Invokes the function.
    * @param container The calling container.
    * @param dynamicDependencies Additional dependencies to use during invocation.
    * @return The result of the function invocation.
    */
    invoke(container: Container, dynamicDependencies?: any[]): any;
}
/**
* Used to configure a Container instance.
*/
export interface ContainerConfiguration {
    /**
    * An optional callback which will be called when any function needs an InvocationHandler created (called once per Function).
    */
    onHandlerCreated?: (handler: InvocationHandler) => InvocationHandler;
    handlers?: Map<any, any>;
}
/**
* A lightweight, extensible dependency injection container.
*/
export class Container {
    /**
    * The global root Container instance. Available if makeGlobal() has been called. Aurelia Framework calls makeGlobal().
    */
    static instance: Container;
    /**
    * The parent container in the DI hierarchy.
    */
    parent: Container;
    /**
    * The root container in the DI hierarchy.
    */
    root: Container;
    /**
    * Creates an instance of Container.
    * @param configuration Provides some configuration for the new Container instance.
    */
    constructor(configuration?: ContainerConfiguration);
    /**
    * Makes this container instance globally reachable through Container.instance.
    */
    makeGlobal(): Container;
    /**
    * Sets an invocation handler creation callback that will be called when new InvocationsHandlers are created (called once per Function).
    * @param onHandlerCreated The callback to be called when an InvocationsHandler is created.
    */
    setHandlerCreatedCallback(onHandlerCreated: (handler: InvocationHandler) => InvocationHandler): void;
    /**
    * Registers an existing object instance with the container.
    * @param key The key that identifies the dependency at resolution time; usually a constructor function.
    * @param instance The instance that will be resolved when the key is matched. This defaults to the key value when instance is not supplied.
    * @return The resolver that was registered.
    */
    registerInstance(key: any, instance?: any): Resolver;
    /**
    * Registers a type (constructor function) such that the container always returns the same instance for each request.
    * @param key The key that identifies the dependency at resolution time; usually a constructor function.
    * @param fn The constructor function to use when the dependency needs to be instantiated. This defaults to the key value when fn is not supplied.
    * @return The resolver that was registered.
    */
    registerSingleton(key: any, fn?: Function): Resolver;
    /**
    * Registers a type (constructor function) such that the container returns a new instance for each request.
    * @param key The key that identifies the dependency at resolution time; usually a constructor function.
    * @param fn The constructor function to use when the dependency needs to be instantiated. This defaults to the key value when fn is not supplied.
    * @return The resolver that was registered.
    */
    registerTransient(key: any, fn?: Function): Resolver;
    /**
    * Registers a custom resolution function such that the container calls this function for each request to obtain the instance.
    * @param key The key that identifies the dependency at resolution time; usually a constructor function.
    * @param handler The resolution function to use when the dependency is needed.
    * @return The resolver that was registered.
    */
    registerHandler(key: any, handler: (container?: Container, key?: any, resolver?: Resolver) => any): Resolver;
    /**
    * Registers an additional key that serves as an alias to the original DI key.
    * @param originalKey The key that originally identified the dependency; usually a constructor function.
    * @param aliasKey An alternate key which can also be used to resolve the same dependency  as the original.
    * @return The resolver that was registered.
    */
    registerAlias(originalKey: any, aliasKey: any): Resolver;
    /**
    * Registers a custom resolution function such that the container calls this function for each request to obtain the instance.
    * @param key The key that identifies the dependency at resolution time; usually a constructor function.
    * @param resolver The resolver to use when the dependency is needed.
    * @return The resolver that was registered.
    */
    registerResolver(key: any, resolver: Resolver): Resolver;
    /**
    * Registers a type (constructor function) by inspecting its registration annotations. If none are found, then the default singleton registration is used.
    * @param key The key that identifies the dependency at resolution time; usually a constructor function.
    * @param fn The constructor function to use when the dependency needs to be instantiated. This defaults to the key value when fn is not supplied.
    */
    autoRegister(key: any, fn?: Function): Resolver;
    /**
    * Registers an array of types (constructor functions) by inspecting their registration annotations. If none are found, then the default singleton registration is used.
    * @param fns The constructor function to use when the dependency needs to be instantiated.
    */
    autoRegisterAll(fns: any[]): void;
    /**
    * Unregisters based on key.
    * @param key The key that identifies the dependency at resolution time; usually a constructor function.
    */
    unregister(key: any): void;
    /**
    * Inspects the container to determine if a particular key has been registred.
    * @param key The key that identifies the dependency at resolution time; usually a constructor function.
    * @param checkParent Indicates whether or not to check the parent container hierarchy.
    * @return Returns true if the key has been registred; false otherwise.
    */
    hasResolver(key: any, checkParent?: boolean): boolean;
    /**
    * Gets the resolver for the particular key, if it has been registered.
    * @param key The key that identifies the dependency at resolution time; usually a constructor function.
    * @return Returns the resolver, if registred, otherwise undefined.
    */
    getResolver(key: any): any;
    /**
    * Resolves a single instance based on the provided key.
    * @param key The key that identifies the object to resolve.
    * @return Returns the resolved instance.
    */
    get(key: any): any;
    _get(key: any): any;
    /**
    * Resolves all instance registered under the provided key.
    * @param key The key that identifies the objects to resolve.
    * @return Returns an array of the resolved instances.
    */
    getAll(key: any): any[];
    /**
    * Creates a new dependency injection container whose parent is the current container.
    * @return Returns a new container instance parented to this.
    */
    createChild(): Container;
    /**
    * Invokes a function, recursively resolving its dependencies.
    * @param fn The function to invoke with the auto-resolved dependencies.
    * @param dynamicDependencies Additional function dependencies to use during invocation.
    * @return Returns the instance resulting from calling the function.
    */
    invoke(fn: Function & {
        name?: string;
    }, dynamicDependencies?: any[]): any;
    _createInvocationHandler(fn: Function & {
        inject?: any;
    }): InvocationHandler;
}
/**
* Decorator: Directs the TypeScript transpiler to write-out type metadata for the decorated class.
*/
export function autoinject(potentialTarget?: any): any;
/**
* Decorator: Specifies the dependencies that should be injected by the DI Container into the decoratored class/function.
*/
export function inject(...rest: any[]): any;
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dialog/master/dist/commonjs/dialog-settings.d.ts
declare module '~aurelia-dialog/dist/commonjs/dialog-settings' {
import { Container } from '~aurelia-dialog~aurelia-dependency-injection/dist/aurelia-dependency-injection';
import { ViewStrategy } from '~aurelia-dialog~aurelia-templating/dist/aurelia-templating';
export type ActionKey = 'Escape' | 'Enter';
/**
 * All available dialog settings.
 */
export interface DialogSettings {
    [setting: string]: any;
    /**
     * The view model url, constructor or instance for the dialog.
     */
    viewModel?: string | {
        new (...params: any[]): object;
    } | object;
    /**
     * The view url or view strategy to override the default view location convention.
     */
    view?: string | ViewStrategy;
    /**
     * Data to be passed to the "activate" hook on the view model.
     */
    model?: any;
    /**
     * The element that will parent the dialog.
     */
    host?: Element;
    /**
     * The child Container for the dialog creation.
     * One will be created from the root if not provided.
     */
    childContainer?: Container;
    /**
     * When set to "false" allows the dialog to be closed with ESC key or clicking outside the dialog.
     * When set to "true" the dialog does not close on ESC key or clicking outside of it.
     */
    lock?: boolean;
    /**
     * Allows for closing the top most dialog via the keyboard.
     * When set to "false" no action will be taken.
     * If set to "true", "Escape" or an array containing "Escape"
     * the dialog will be "cancel" closed when the ESC key is pressed.
     * If set to "Enter" or and array containing "Enter"
     * the dialog will be "ok" closed  when the ENTER key is pressed.
     * Using the array format allows combining the ESC and ENTER keys.
     */
    keyboard?: boolean | ActionKey | ActionKey[];
    /**
     * When set to "true" allows for the dismissal of the dialog by clicking outside of it.
     */
    overlayDismiss?: boolean;
    /**
     * The z-index of the dialog.
     * In the terms of the DialogRenderer it is applied to the dialog overlay and the dialog container.
     */
    startingZIndex?: number;
    /**
     * Centers the dialog only horizontally.
     */
    centerHorizontalOnly?: boolean;
    /**
     * When set to true conveys a cancellation as a rejection.
     */
    rejectOnCancel?: boolean;
    /**
     * When set to true transitions will not be awaited to end.
     */
    ignoreTransitions?: boolean;
    /**
     * Usde to provide custom positioning logic.
     * When invoked the function is passed the dialog container and the dialog overlay elements.
     */
    position?: (dialogContainer: Element, dialogOverlay: Element) => void;
}
}
declare module 'aurelia-dialog/dist/commonjs/dialog-settings' {
export * from '~aurelia-dialog/dist/commonjs/dialog-settings';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dialog/master/dist/commonjs/renderer.d.ts
declare module '~aurelia-dialog/dist/commonjs/renderer' {
import { DialogController } from '~aurelia-dialog/dist/commonjs/dialog-controller';
export interface RendererStatic {
    new (): Renderer;
}
/**
 * An abstract base class for implementors of the basic Renderer API.
 */
export class Renderer {
    /**
     * Gets an anchor for the ViewSlot to insert a view into.
     * @returns A DOM element.
     */
    getDialogContainer(): Element;
    /**
     * Displays the dialog.
     * @returns Promise A promise that resolves when the dialog has been displayed.
     */
    showDialog(dialogController: DialogController): Promise<any>;
    /**
     * Hides the dialog.
     * @returns Promise A promise that resolves when the dialog has been hidden.
     */
    hideDialog(dialogController: DialogController): Promise<any>;
}
}
declare module 'aurelia-dialog/dist/commonjs/renderer' {
export * from '~aurelia-dialog/dist/commonjs/renderer';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dialog/master/dist/commonjs/dialog-cancel-error.d.ts
declare module '~aurelia-dialog/dist/commonjs/dialog-cancel-error' {
/**
 * The error thrown when a "cancel" occurs and DialogSettings.rejectOnCancel is set to "true".
 */
export interface DialogCancelError extends Error {
    wasCancelled: true;
    output?: any;
}
}
declare module 'aurelia-dialog/dist/commonjs/dialog-cancel-error' {
export * from '~aurelia-dialog/dist/commonjs/dialog-cancel-error';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dialog/master/dist/commonjs/dialog-result.d.ts
declare module '~aurelia-dialog/dist/commonjs/dialog-result' {
import { DialogController } from '~aurelia-dialog/dist/commonjs/dialog-controller';
/**
 * The result that a dialog cancelable operation resolves to.
 */
export interface DialogCancelableOperationResult {
    wasCancelled: boolean;
}
/**
 * The result that a dialog operation resolves to when cancelled.
 */
export interface DialogCancelResult {
    wasCancelled: true;
}
/**
 * The result received when a dialog closes.
 */
export interface DialogCloseResult extends DialogCancelableOperationResult {
    /**
     * The provided close value.
     */
    output?: any;
}
/**
 * The result received when a dialog opens.
 */
export interface DialogOpenResult {
    wasCancelled: false;
    /**
     * The controller for the open dialog.
     */
    controller: DialogController;
    /**
     * Promise that settles when the dialog is closed.
     */
    closeResult: Promise<DialogCloseResult>;
}
}
declare module 'aurelia-dialog/dist/commonjs/dialog-result' {
export * from '~aurelia-dialog/dist/commonjs/dialog-result';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dialog/master/dist/commonjs/dialog-service.d.ts
declare module '~aurelia-dialog/dist/commonjs/dialog-service' {
import { Container } from '~aurelia-dialog~aurelia-dependency-injection/dist/aurelia-dependency-injection';
import { CompositionEngine } from '~aurelia-dialog~aurelia-templating/dist/aurelia-templating';
import { DialogOpenResult, DialogCloseResult, DialogCancelResult } from '~aurelia-dialog/dist/commonjs/dialog-result';
import { DialogSettings } from '~aurelia-dialog/dist/commonjs/dialog-settings';
import { DialogController } from '~aurelia-dialog/dist/commonjs/dialog-controller';
export type DialogCancellableOpenResult = DialogOpenResult | DialogCancelResult;
export interface DialogOpenPromise<T extends DialogCancellableOpenResult> extends Promise<T> {
    whenClosed(onfulfilled?: ((value: DialogCloseResult) => DialogCloseResult | PromiseLike<DialogCloseResult>) | undefined | null, onrejected?: ((reason: any) => DialogCloseResult | PromiseLike<DialogCloseResult>) | undefined | null): Promise<DialogCloseResult>;
    whenClosed<TResult>(onfulfilled: ((value: DialogCloseResult) => DialogCloseResult | PromiseLike<DialogCloseResult>) | undefined | null, onrejected: (reason: any) => TResult | PromiseLike<TResult>): Promise<DialogCloseResult | TResult>;
    whenClosed<TResult>(onfulfilled: (value: DialogCloseResult) => TResult | PromiseLike<TResult>, onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<TResult>;
    whenClosed<TResult1, TResult2>(onfulfilled: (value: DialogCloseResult) => TResult1 | PromiseLike<TResult1>, onrejected: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2>;
}
/**
 * A service allowing for the creation of dialogs.
 */
export class DialogService {
    private container;
    private compositionEngine;
    private defaultSettings;
    /**
     * The current dialog controllers
     */
    controllers: DialogController[];
    /**
     * Is there an open dialog
     */
    hasOpenDialog: boolean;
    hasActiveDialog: boolean;
    constructor(container: Container, compositionEngine: CompositionEngine, defaultSettings: DialogSettings);
    private validateSettings(settings);
    private createCompositionContext(childContainer, host, settings);
    private ensureViewModel(compositionContext);
    private _cancelOperation(rejectOnCancel);
    private composeAndShowDialog(compositionContext, dialogController);
    /**
     * Opens a new dialog.
     * @param settings Dialog settings for this dialog instance.
     * @return Promise A promise that settles when the dialog is closed.
     */
    open(settings: DialogSettings & {
        rejectOnCancel: true;
    }): DialogOpenPromise<DialogOpenResult>;
    open(settings?: DialogSettings & {
        rejectOnCancel?: false | boolean;
    }): DialogOpenPromise<DialogCancellableOpenResult>;
    /**
     * Closes all open dialogs at the time of invocation.
     * @return Promise<DialogController[]> All controllers whose close operation was cancelled.
     */
    closeAll(): Promise<DialogController[]>;
}
}
declare module 'aurelia-dialog/dist/commonjs/dialog-service' {
export * from '~aurelia-dialog/dist/commonjs/dialog-service';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dialog/master/dist/commonjs/dialog-controller.d.ts
declare module '~aurelia-dialog/dist/commonjs/dialog-controller' {
import { Controller } from '~aurelia-dialog~aurelia-templating/dist/aurelia-templating';
import { Renderer } from '~aurelia-dialog/dist/commonjs/renderer';
import { DialogCancelableOperationResult } from '~aurelia-dialog/dist/commonjs/dialog-result';
import { DialogSettings } from '~aurelia-dialog/dist/commonjs/dialog-settings';
/**
 * A controller object for a Dialog instance.
 */
export class DialogController {
    private resolve;
    private reject;
    /**
     * The settings used by this controller.
     */
    settings: DialogSettings;
    renderer: Renderer;
    controller: Controller;
    /**
     * Creates an instance of DialogController.
     */
    constructor(renderer: Renderer, settings: DialogSettings, resolve: (data?: any) => void, reject: (reason: any) => void);
    /**
     * Closes the dialog with a successful output.
     * @param output The returned success output.
     */
    ok(output?: any): Promise<DialogCancelableOperationResult>;
    /**
     * Closes the dialog with a cancel output.
     * @param output The returned cancel output.
     */
    cancel(output?: any): Promise<DialogCancelableOperationResult>;
    /**
     * Closes the dialog with an error result.
     * @param message An error message.
     * @returns Promise An empty promise object.
     */
    error(message: any): Promise<void>;
    /**
     * Closes the dialog.
     * @param ok Whether or not the user input signified success.
     * @param output The specified output.
     * @returns Promise An empty promise object.
     */
    close(ok: boolean, output?: any): Promise<DialogCancelableOperationResult>;
}
}
declare module 'aurelia-dialog/dist/commonjs/dialog-controller' {
export * from '~aurelia-dialog/dist/commonjs/dialog-controller';
}

// Generated by typings
// Source: https://raw.githubusercontent.com/aurelia/dialog/master/dist/commonjs/aurelia-dialog.d.ts
declare module '~aurelia-dialog/dist/commonjs/aurelia-dialog' {
import { FrameworkConfiguration } from 'aurelia-framework';
import { DialogConfiguration } from '~aurelia-dialog/dist/commonjs/dialog-configuration';
export function configure(frameworkConfig: FrameworkConfiguration, callback?: (config: DialogConfiguration) => void): void;
export * from '~aurelia-dialog/dist/commonjs/ux-dialog';
export * from '~aurelia-dialog/dist/commonjs/ux-dialog-header';
export * from '~aurelia-dialog/dist/commonjs/ux-dialog-body';
export * from '~aurelia-dialog/dist/commonjs/ux-dialog-footer';
export * from '~aurelia-dialog/dist/commonjs/attach-focus';
export * from '~aurelia-dialog/dist/commonjs/interfaces';
export * from '~aurelia-dialog/dist/commonjs/dialog-settings';
export * from '~aurelia-dialog/dist/commonjs/dialog-configuration';
export * from '~aurelia-dialog/dist/commonjs/renderer';
export * from '~aurelia-dialog/dist/commonjs/dialog-cancel-error';
export * from '~aurelia-dialog/dist/commonjs/dialog-result';
export * from '~aurelia-dialog/dist/commonjs/dialog-service';
export * from '~aurelia-dialog/dist/commonjs/dialog-controller';
}
declare module 'aurelia-dialog/dist/commonjs/aurelia-dialog' {
export * from '~aurelia-dialog/dist/commonjs/aurelia-dialog';
}
declare module 'aurelia-dialog' {
export * from '~aurelia-dialog/dist/commonjs/aurelia-dialog';
}
